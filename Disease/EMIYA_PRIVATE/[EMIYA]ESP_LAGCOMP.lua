local a={}local b,c={},{}local d=globals.tickinterval;local e=entity.is_enemy;local f=entity.get_prop;local g=entity.is_dormant;local h=entity.is_alive;local i=entity.get_origin;local j=entity.get_local_player;local k=entity.get_player_resource;local l=entity.get_bounding_box;local m=entity.get_player_name;local n=renderer.text;local o=renderer.world_to_screen;local p=renderer.line;local q=table.insert;local r=client.trace_line;local s=math.floor;local t=globals.frametime;local u=cvar.sv_gravity;local v=cvar.sv_jump_impulse;local w=function(x)return s(0.5+x/d())end;local y=function(z,A)return{z[1]-A[1],z[2]-A[2],z[3]-A[3]}end;local B=function(z,A)return{z[1]+A[1],z[2]+A[2],z[3]+A[3]}end;local C=function(D,E)return D*D+E*E end;local F=function(G,H)local G=G~=nil and G or false;local H=H~=nil and H or true;local I={}local J=j()local K=k()for L=1,globals.maxplayers()do local M,N=true,true;if G and not e(L)then M=false end;if M then if H and f(K,'m_bAlive',L)~=1 then N=false end;if N then q(I,L)end end end;return I end;local O=function(P,Q,R,S)local T=d()local u=u:get_float()*T;local v=v:get_float()*T;local U,V=Q,Q;local W={f(P,'m_vecVelocity')}local X=W[3]>0 and-u or v;for Y=1,S do V=U;U={U[1]+W[1]*T,U[2]+W[2]*T,U[3]+(W[3]+X)*T}local Z=r(-1,V[1],V[2],V[3],U[1],U[2],U[3])if Z<=0.99 then return V end end;return U end;local function _()local J=j()local a0=F(true,true)for Y=1,#a0 do local a1=a0[Y]local a2=b[a1]if g(a1)or not h(a1)then b[a1]=nil;c[a1]=nil;a[a1]=nil else local a3={i(a1)}local a4=w(f(a1,'m_flSimulationTime'))if a2~=nil then local a5=a4-a2.tick;if a5<0 or a5>0 and a5<=64 then local a6=f(a1,'m_fFlags')local a7=y(a3,a2.origin)local a8=C(a7[1],a7[2])local a9=O(a1,a3,a6,a5-1)if a5<0 then a[a1]=1 end;c[a1]={tick=a5-1,origin=a3,predicted_origin=a9,tickbase=a5<0,lagcomp=a8>4096}end end;if a[a1]==nil then a[a1]=0 end;b[a1]={tick=a4,origin=a3}end end end;local function aa()local J=j()local K=k()if not J or not h(J)then return end;local ab=f(J,"m_iObserverMode")local ac={}if ab==0 or ab==1 or ab==2 or ab==6 then ac=F(true,true)elseif ab==4 or ab==5 then local ad=F(false,true)local ae=f(J,"m_hObserverTarget")local af=f(ae,"m_iTeamNum")for ag=1,#ad do if af~=f(ad[ag],"m_iTeamNum")and ad[ag]~=J then q(ac,ad[ag])end end end;if#ac==0 then return end;for a1,ah in pairs(c)do if h(a1)and e(a1)and ah~=nil then if ah.lagcomp then local ai=ah.predicted_origin;local aj=B({f(a1,'m_vecMins')},ai)local ak=B({f(a1,'m_vecMaxs')},ai)local al={{aj[1],aj[2],aj[3]},{aj[1],ak[2],aj[3]},{ak[1],ak[2],aj[3]},{ak[1],aj[2],aj[3]},{aj[1],aj[2],ak[3]},{aj[1],ak[2],ak[3]},{ak[1],ak[2],ak[3]},{ak[1],aj[2],ak[3]}}local am={{0,1},{1,2},{2,3},{3,0},{5,6},{6,7},{1,4},{4,8},{0,4},{1,5},{2,6},{3,7},{5,8},{7,8},{3,4}}for Y=1,#am do if Y==1 then local Q={i(a1)}local an={o(Q[1],Q[2],Q[3])}local ao={o(aj[1],aj[2],aj[3])}if an[1]~=nil and ao[1]~=nil then p(an[1],an[2],ao[1],ao[2],137,160,237,255)end end;if al[am[Y][1]]~=nil and al[am[Y][2]]~=nil then local ap={o(al[am[Y][1]][1],al[am[Y][1]][2],al[am[Y][1]][3])}local aq={o(al[am[Y][2]][1],al[am[Y][2]][2],al[am[Y][2]][3])}p(ap[1],ap[2],aq[1],aq[2],137,160,237,255)end end end;local ar={[0]='',[1]='LAG COMP BREAKER',[2]='EXPLOITING'}local as,at,au,av,z=l(a1)local aw=0;if a[a1]>0 then a[a1]=a[a1]-t()*2;a[a1]=a[a1]<0 and 0 or a[a1]aw=a[a1]end;local ax=ah.tickbase or a[a1]>0;local ay=ah.lagcomp;if not ax or ah.lagcomp then aw=z end;if as~=nil and z>0 then local az=m(a1)local aA=az==''and-8 or 0;n(as+(au-as)/2,at-18+aA,255,128,128,aw*255,'c',0,ar[ax and 2 or(ay and 1 or 0)])end end end end;client.set_event_callback('paint',aa)client.set_event_callback('net_update_end',_)